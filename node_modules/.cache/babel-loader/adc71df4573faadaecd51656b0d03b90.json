{"ast":null,"code":"const fetchSearch = (searchTerm, path) => {\n  return fetch(`http://localhost:4000/${path}/${searchTerm}`).then(response => response.json()).then(resData => resData.results);\n};\n\nconst wrapPromise = promise => {\n  let status = 'pending';\n  let result = '';\n  let suspender = promise.then(response => {\n    status = 'success';\n    result = response;\n  }, err => {\n    status = 'error';\n    result = err;\n  });\n  return {\n    read() {\n      if (status === 'pending') {\n        throw suspender;\n      } else if (status === 'error') {\n        throw result;\n      }\n\n      return result;\n    }\n\n  };\n};\n\nexport const createResource = (searchTerm, path) => {\n  return {\n    result: wrapPromise(fetchSearch(searchTerm, path))\n  };\n};","map":{"version":3,"sources":["/Users/brittanyouellette/Desktop/KSDS/Extended/RR-Music-Search/src/helper.js"],"names":["fetchSearch","searchTerm","path","fetch","then","response","json","resData","results","wrapPromise","promise","status","result","suspender","err","read","createResource"],"mappings":"AAAA,MAAMA,WAAW,GAAG,CAACC,UAAD,EAAaC,IAAb,KAAsB;AACtC,SAAOC,KAAK,CAAE,yBAAwBD,IAAK,IAAGD,UAAW,EAA7C,CAAL,CACNG,IADM,CACDC,QAAQ,IAAIA,QAAQ,CAACC,IAAT,EADX,EAENF,IAFM,CAEDG,OAAO,IAAIA,OAAO,CAACC,OAFlB,CAAP;AAGH,CAJD;;AAMA,MAAMC,WAAW,GAAIC,OAAD,IAAa;AAC7B,MAAIC,MAAM,GAAG,SAAb;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,SAAS,GAAGH,OAAO,CAACN,IAAR,CAAaC,QAAQ,IAAI;AACrCM,IAAAA,MAAM,GAAG,SAAT;AACAC,IAAAA,MAAM,GAAGP,QAAT;AACH,GAHe,EAGbS,GAAG,IAAI;AACNH,IAAAA,MAAM,GAAG,OAAT;AACAC,IAAAA,MAAM,GAAGE,GAAT;AACH,GANe,CAAhB;AAOA,SAAO;AACHC,IAAAA,IAAI,GAAG;AACH,UAAGJ,MAAM,KAAK,SAAd,EAAyB;AACrB,cAAME,SAAN;AACH,OAFD,MAEO,IAAIF,MAAM,KAAK,OAAf,EAAwB;AAC3B,cAAMC,MAAN;AACH;;AACD,aAAOA,MAAP;AACH;;AARE,GAAP;AAUH,CApBD;;AAsBA,OAAO,MAAMI,cAAc,GAAG,CAACf,UAAD,EAAaC,IAAb,KAAsB;AAChD,SAAO;AACHU,IAAAA,MAAM,EAAEH,WAAW,CAACT,WAAW,CAACC,UAAD,EAAaC,IAAb,CAAZ;AADhB,GAAP;AAGH,CAJM","sourcesContent":["const fetchSearch = (searchTerm, path) => {\n    return fetch(`http://localhost:4000/${path}/${searchTerm}`)\n    .then(response => response.json())\n    .then(resData => resData.results)\n}\n\nconst wrapPromise = (promise) => {\n    let status = 'pending'\n    let result = ''\n    let suspender = promise.then(response => {\n        status = 'success'\n        result = response\n    }, err => {\n        status = 'error'\n        result = err\n    })\n    return {\n        read() {\n            if(status === 'pending') {\n                throw suspender\n            } else if (status === 'error') {\n                throw result\n            }\n            return result\n        }\n    }\n}\n\nexport const createResource = (searchTerm, path) => {\n    return {\n        result: wrapPromise(fetchSearch(searchTerm, path))\n    }\n}"]},"metadata":{},"sourceType":"module"}